{"version":3,"sources":["../../src/expo/isExpoElectron.ts","../../src/metro/withExpoElectronAdapter.ts"],"names":[],"mappings":";AAGO,IAAM,qBAAA,GAAyB,OAAO,OAAA,KAAY,WAAA,IAAe,QAAQ,GAAA,IAAO,OAAA,CAAQ,IAAI,aAAA,IAAiB;;;ACC7G,IAAM,uBAAA,GAA0B,CAAC,MAAA,KAAqC;AAC3E,EAAA,MAAM,sBAAA,GAAyB,OAAO,QAAA,EAAU,cAAA;AAGhD,EAAA,MAAM,kBAAkB,qBAAA,GACpB,CAAC,UAAU,CAAA,GACX,CAAC,SAAS,CAAA;AAEd,EAAA,OAAO;AAAA,IACL,GAAG,MAAA;AAAA,IACH,QAAA,EAAU;AAAA,MACR,GAAG,MAAA,CAAO,QAAA;AAAA,MACV,SAAA,EAAW;AAAA,QACT,GAAG,eAAA;AAAA,QACH,GAAI,MAAA,CAAO,QAAA,EAAU,SAAA,IAAa;AAAC,OACrC;AAAA,MACA,cAAA,EAAgB,CAAC,OAAA,EAAS,UAAA,EAAY,QAAA,KAAa;AAEjD,QAAA,MAAM,YAAY,OAAA,CAAQ,gBAAA,IACR,CAAC,OAAA,CAAQ,gBAAA,CAAiB,SAAS,cAAc,CAAA;AAEnE,QAAA,IAAI,SAAA,IAAa,aAAa,KAAA,EAAO;AAEnC,UAAA,MAAM,aAAA,GAAgB,wBAClB,CAAC,UAAA,EAAY,KAAK,CAAA,GAClB,CAAC,WAAW,KAAK,CAAA;AAGrB,UAAA,KAAA,MAAW,kBAAkB,aAAA,EAAe;AAC1C,YAAA,IAAI;AACF,cAAA,IAAI,sBAAA,EAAwB;AAC1B,gBAAA,OAAO,sBAAA,CAAuB,OAAA,EAAS,UAAA,EAAY,cAAc,CAAA;AAAA,cACnE;AACA,cAAA,OAAO,OAAA,CAAQ,cAAA,CAAe,OAAA,EAAS,UAAA,EAAY,cAAc,CAAA;AAAA,YACnE,SAAS,KAAA,EAAO;AAEd,cAAA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAGA,QAAA,IAAI,sBAAA,EAAwB;AAC1B,UAAA,OAAO,sBAAA,CAAuB,OAAA,EAAS,UAAA,EAAY,QAAQ,CAAA;AAAA,QAC7D;AACA,QAAA,OAAO,OAAA,CAAQ,cAAA,CAAe,OAAA,EAAS,UAAA,EAAY,QAAQ,CAAA;AAAA,MAC7D;AAAA;AACF,GACF;AACF","file":"index.mjs","sourcesContent":["// isMetroElectronConfig.ts\r\n// Checks if we're running in the context of the Metro Bundler for Electron.\r\n\r\nexport const isExpoElectronRuntime = (typeof process !== 'undefined' && process.env && process.env.EXPO_PLATFORM == \"electron\");","import { MetroConfig } from 'metro-config';\r\nimport { isExpoElectronRuntime } from '../expo/isExpoElectron';\r\nimport path from 'path';\r\n\r\nexport const withExpoElectronAdapter = (config: MetroConfig): MetroConfig => {\r\n  const originalResolveRequest = config.resolver?.resolveRequest;\r\n  \r\n  // Only add \"browser\" platform if NOT in Electron runtime\r\n  const customPlatforms = isExpoElectronRuntime \r\n    ? [\"electron\"]\r\n    : [\"browser\"];\r\n  \r\n  return {\r\n    ...config,\r\n    resolver: {\r\n      ...config.resolver,\r\n      platforms: [\r\n        ...customPlatforms,\r\n        ...(config.resolver?.platforms || [])\r\n      ],\r\n      resolveRequest: (context, moduleName, platform) => {\r\n        // Only apply custom resolutions for component files in our app, and not for node_modules\r\n        const isAppCode = context.originModulePath && \r\n                          !context.originModulePath.includes('node_modules');\r\n        \r\n        if (isAppCode && platform === \"web\") {\r\n          // Define the fallback chain based on runtime\r\n          const platformChain = isExpoElectronRuntime \r\n            ? [\"electron\", \"web\"]  // electron → web → base\r\n            : [\"browser\", \"web\"];   // browser → web → base\r\n          \r\n          // Try each platform in the chain\r\n          for (const targetPlatform of platformChain) {\r\n            try {\r\n              if (originalResolveRequest) {\r\n                return originalResolveRequest(context, moduleName, targetPlatform);\r\n              }\r\n              return context.resolveRequest(context, moduleName, targetPlatform);\r\n            } catch (error) {\r\n              // If this platform doesn't exist, continue to next in chain\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Default resolution (base .tsx file or other platforms)\r\n        if (originalResolveRequest) {\r\n          return originalResolveRequest(context, moduleName, platform);\r\n        }\r\n        return context.resolveRequest(context, moduleName, platform);\r\n      }\r\n    }\r\n  }\r\n}"]}